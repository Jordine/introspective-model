"""
Generate training data for concept-vector training experiment.

Same as original but uses coherent concept vectors (from generate_concept_vectors.py)
instead of random unit vectors. Tests whether training on meaningful concept vectors
produces different behavioral generalization than random ones.

Requires: vectors/concepts/all_concept_vectors.pt (generated by generate_concept_vectors.py)

Usage:
    python scripts/generate_concept_training_data.py \
        --n-examples 10000 \
        --output-dir training_data/concept_vectors
"""

import argparse
import json
import random
from pathlib import Path

import torch

from utils import (
    CONTEXT_PROMPTS, ASSISTANT_RESPONSES, DETECTION_QUESTION_VARIANTS,
    DEFAULT_MAGNITUDES, MODEL_CONFIGS, DEFAULT_MODEL,
    save_jsonl,
)


def generate_concept_examples(n_examples, n_concept_vectors, layer_ranges,
                              magnitudes, steered_ratio=0.5,
                              detection_questions=None):
    """Generate training examples using concept vectors."""
    if detection_questions is None:
        detection_questions = DETECTION_QUESTION_VARIANTS

    examples = []
    n_steered = int(n_examples * steered_ratio)
    n_unsteered = n_examples - n_steered

    layer_range_list = list(layer_ranges.values())
    layer_range_names = list(layer_ranges.keys())

    for _ in range(n_steered):
        lr_idx = random.randint(0, len(layer_range_list) - 1)
        lr = layer_range_list[lr_idx]
        examples.append({
            "steered": True,
            "vector_idx": random.randint(0, n_concept_vectors - 1),
            "layer_start": lr[0],
            "layer_end": lr[1],
            "layer_name": layer_range_names[lr_idx],
            "magnitude": random.choice(magnitudes),
            "context_prompt": random.choice(CONTEXT_PROMPTS),
            "assistant_response": random.choice(ASSISTANT_RESPONSES),
            "detection_question": random.choice(detection_questions),
        })

    for _ in range(n_unsteered):
        examples.append({
            "steered": False,
            "vector_idx": None,
            "layer_start": None,
            "layer_end": None,
            "layer_name": None,
            "magnitude": None,
            "context_prompt": random.choice(CONTEXT_PROMPTS),
            "assistant_response": random.choice(ASSISTANT_RESPONSES),
            "detection_question": random.choice(detection_questions),
        })

    random.shuffle(examples)
    return examples


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--n-examples", type=int, default=10000)
    parser.add_argument("--concept-vectors", type=Path,
                        default=Path("vectors/concepts/all_concept_vectors.pt"),
                        help="Path to stacked concept vectors tensor")
    parser.add_argument("--output-dir", type=Path, default=Path("training_data/concept_vectors"))
    parser.add_argument("--model", type=str, default=DEFAULT_MODEL)
    parser.add_argument("--magnitudes", nargs="+", type=float, default=DEFAULT_MAGNITUDES)
    parser.add_argument("--steered-ratio", type=float, default=0.5)
    parser.add_argument("--val-split", type=float, default=0.1)
    parser.add_argument("--seed", type=int, default=42)
    args = parser.parse_args()

    random.seed(args.seed)
    args.output_dir.mkdir(parents=True, exist_ok=True)

    # Load concept vectors to get count
    concept_vecs = torch.load(args.concept_vectors, weights_only=True)
    n_concepts = concept_vecs.shape[0]
    print(f"Loaded {n_concepts} concept vectors ({concept_vecs.shape})")

    config = MODEL_CONFIGS.get(args.model, {})
    layer_ranges = config.get("layer_ranges", {"middle": (21, 42)})

    examples = generate_concept_examples(
        args.n_examples, n_concepts, layer_ranges,
        args.magnitudes, args.steered_ratio,
    )

    n_val = int(len(examples) * args.val_split)
    val = examples[:n_val]
    train = examples[n_val:]

    save_jsonl(train, args.output_dir / "train.jsonl")
    save_jsonl(val, args.output_dir / "val.jsonl")

    n_steered = sum(1 for e in train if e["steered"])
    print(f"Train: {len(train)} ({n_steered} steered with concept vectors)")
    print(f"Val: {len(val)}")
    print(f"Saved to {args.output_dir}")


if __name__ == "__main__":
    main()
